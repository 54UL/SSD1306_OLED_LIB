/*
 * File:   Oled_1306Driver.c
 * Author: Saul
 *
 * 
 */

#include "Oled_1306Driver.h"
#include "I2C_Driver.h"
#include "delay.h"
#include "stdint.h"


#if defined(OLED_LOAD_DEFAULT_FONT)
uint8_t MEMORY_KEYWORD DefaultFont[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // sp
0x00, 0x00, 0x00, 0x2f, 0x00, 0x00,   // !
0x00, 0x00, 0x07, 0x00, 0x07, 0x00,   // "
0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14,   // #
0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12,   // $
0x00, 0x23, 0x13, 0x08, 0x64, 0x62,   // %
0x00, 0x36, 0x49, 0x55, 0x22, 0x50,   // &
0x00, 0x00, 0x05, 0x03, 0x00, 0x00,   // '
0x00, 0x00, 0x1c, 0x22, 0x41, 0x00,   // (
0x00, 0x00, 0x41, 0x22, 0x1c, 0x00,   // )
0x00, 0x14, 0x08, 0x3E, 0x08, 0x14,   // *
0x00, 0x08, 0x08, 0x3E, 0x08, 0x08,   // +
0x00, 0x00, 0x00, 0xA0, 0x60, 0x00,   // ,
0x00, 0x08, 0x08, 0x08, 0x08, 0x08,   // -
0x00, 0x00, 0x60, 0x60, 0x00, 0x00,   // .
0x00, 0x20, 0x10, 0x08, 0x04, 0x02,   // /
0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E,   // 0
0x00, 0x00, 0x42, 0x7F, 0x40, 0x00,   // 1
0x00, 0x42, 0x61, 0x51, 0x49, 0x46,   // 2
0x00, 0x21, 0x41, 0x45, 0x4B, 0x31,   // 3
0x00, 0x18, 0x14, 0x12, 0x7F, 0x10,   // 4
0x00, 0x27, 0x45, 0x45, 0x45, 0x39,   // 5
0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30,   // 6
0x00, 0x01, 0x71, 0x09, 0x05, 0x03,   // 7
0x00, 0x36, 0x49, 0x49, 0x49, 0x36,   // 8
0x00, 0x06, 0x49, 0x49, 0x29, 0x1E,   // 9
0x00, 0x00, 0x36, 0x36, 0x00, 0x00,   // :
0x00, 0x00, 0x56, 0x36, 0x00, 0x00,   // ;
0x00, 0x08, 0x14, 0x22, 0x41, 0x00,   // <
0x00, 0x14, 0x14, 0x14, 0x14, 0x14,   // =
0x00, 0x00, 0x41, 0x22, 0x14, 0x08,   // >
0x00, 0x02, 0x01, 0x51, 0x09, 0x06,   // ?
0x00, 0x32, 0x49, 0x59, 0x51, 0x3E,   // @
0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C,   // A
0x00, 0x7F, 0x49, 0x49, 0x49, 0x36,   // B
0x00, 0x3E, 0x41, 0x41, 0x41, 0x22,   // C
0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C,   // D
0x00, 0x7F, 0x49, 0x49, 0x49, 0x41,   // E
0x00, 0x7F, 0x09, 0x09, 0x09, 0x01,   // F
0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A,   // G
0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F,   // H
0x00, 0x00, 0x41, 0x7F, 0x41, 0x00,   // I
0x00, 0x20, 0x40, 0x41, 0x3F, 0x01,   // J
0x00, 0x7F, 0x08, 0x14, 0x22, 0x41,   // K
0x00, 0x7F, 0x40, 0x40, 0x40, 0x40,   // L
0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F,   // M
0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F,   // N
0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E,   // O
0x00, 0x7F, 0x09, 0x09, 0x09, 0x06,   // P
0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E,   // Q
0x00, 0x7F, 0x09, 0x19, 0x29, 0x46,   // R
0x00, 0x46, 0x49, 0x49, 0x49, 0x31,   // S
0x00, 0x01, 0x01, 0x7F, 0x01, 0x01,   // T
0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F,   // U
0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F,   // V
0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F,   // W
0x00, 0x63, 0x14, 0x08, 0x14, 0x63,   // X
0x00, 0x07, 0x08, 0x70, 0x08, 0x07,   // Y
0x00, 0x61, 0x51, 0x49, 0x45, 0x43,   // Z
0x00, 0x00, 0x7F, 0x41, 0x41, 0x00,   // [
0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,   // Backslash (Checker pattern)
0x00, 0x00, 0x41, 0x41, 0x7F, 0x00,   // ]
0x00, 0x04, 0x02, 0x01, 0x02, 0x04,   // ^
0x00, 0x40, 0x40, 0x40, 0x40, 0x40,   // _
0x00, 0x00, 0x03, 0x05, 0x00, 0x00,   // `
0x00, 0x20, 0x54, 0x54, 0x54, 0x78,   // a
0x00, 0x7F, 0x48, 0x44, 0x44, 0x38,   // b
0x00, 0x38, 0x44, 0x44, 0x44, 0x20,   // c
0x00, 0x38, 0x44, 0x44, 0x48, 0x7F,   // d
0x00, 0x38, 0x54, 0x54, 0x54, 0x18,   // e
0x00, 0x08, 0x7E, 0x09, 0x01, 0x02,   // f
0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C,   // g
0x00, 0x7F, 0x08, 0x04, 0x04, 0x78,   // h
0x00, 0x00, 0x44, 0x7D, 0x40, 0x00,   // i
0x00, 0x40, 0x80, 0x84, 0x7D, 0x00,   // j
0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,   // k
0x00, 0x00, 0x41, 0x7F, 0x40, 0x00,   // l
0x00, 0x7C, 0x04, 0x18, 0x04, 0x78,   // m
0x00, 0x7C, 0x08, 0x04, 0x04, 0x78,   // n
0x00, 0x38, 0x44, 0x44, 0x44, 0x38,   // o
0x00, 0xFC, 0x24, 0x24, 0x24, 0x18,   // p
0x00, 0x18, 0x24, 0x24, 0x18, 0xFC,   // q
0x00, 0x7C, 0x08, 0x04, 0x04, 0x08,   // r
0x00, 0x48, 0x54, 0x54, 0x54, 0x20,   // s
0x00, 0x04, 0x3F, 0x44, 0x40, 0x20,   // t
0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C,   // u
0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C,   // v
0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C,   // w
0x00, 0x44, 0x28, 0x10, 0x28, 0x44,   // x
0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C,   // y
0x00, 0x44, 0x64, 0x54, 0x4C, 0x44,   // z
0x00, 0x00, 0x10, 0x7C, 0x82, 0x00,   // {
0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,   // |
0x00, 0x00, 0x82, 0x7C, 0x10, 0x00,   // }
0x00, 0x00, 0x06, 0x09, 0x09, 0x06    // ~ 
};
#endif

//oled display
void OLED_send(uint8_t Data,uint8_t IsCommand) 
{
     uint8_t controlbyte  = IsCommand ? 0x00 : 0x40;
    I2C_Master_Start();
    I2C_Master_Write(OledAddr<<1);
    I2C_Master_Write(controlbyte);
    I2C_Master_Write(Data);
    I2C_Master_Stop();
}

void OLED_Initialize()
{
  // I2C_Master_Init(400000);
  // I2C_Master_Stop();
  I2C_Master_Init(0);

   
  __delay_ms(100); 

		
   //comand startup
  OLED_send ( SSD1306_DISPLAY_OFF,1);
  OLED_send ( SSD1306_SET_DISPLAY_CLOCK_DIV_RATIO,1);
  OLED_send ( 0x80,1);
  OLED_send ( SSD1306_SET_MULTIPLEX_RATIO,1);
  OLED_send (63,1);
  OLED_send ( SSD1306_SET_DISPLAY_OFFSET,1);
  OLED_send (0x00,1);
  OLED_send ( SSD1306_SET_START_LINE|0x00,1);  
  OLED_send ( SSD1306_CHARGE_PUMP ,1);
  OLED_send (0x14,1);
  OLED_send ( SSD1306_MEMORY_ADDR_MODE ,1);
  OLED_send (0x00,1);  
  OLED_send ( SSD1306_SET_SEGMENT_REMAP| 0x01,1);
  OLED_send ( SSD1306_COM_SCAN_DIR_DEC,1);
  OLED_send ( SSD1306_SET_COM_PINS,1);
  OLED_send ( 0x12,1);
  OLED_send ( SSD1306_SET_CONTRAST_CONTROL,1);
  OLED_send (0xCF,1);
  OLED_send ( SSD1306_SET_PRECHARGE_PERIOD,1);
  OLED_send ( 0xF1,1);
  OLED_send ( SSD1306_SET_VCOM_DESELECT,1);
  OLED_send ( 0x40,1);
  OLED_send ( SSD1306_DISPLAY_ALL_ON_RESUME,1);
  OLED_send ( SSD1306_NORMAL_DISPLAY,1);
  OLED_send ( SSD1306_DEACTIVATE_SCROLL,1);
  OLED_send ( SSD1306_DISPLAY_ON,1);
}
 void OLED_ResetCoords(void)
{
     //for ROWS
    OLED_send(SSD1306_SET_PAGE_ADDR,1);
    OLED_send(0,1);
    OLED_send(7,1);
    //for colums
    OLED_send(SSD1306_SET_COLUMN_ADDR,1);
    OLED_send(0,1);
    OLED_send(127,1);
}

 uint16_t rindex=0;
void OLED_cls() 
{
    OLED_ResetCoords();
	
		
	
    for(;rindex<1024;rindex++)
        OLED_send(0x00,0);
}

void OLED_gotoxy(uint8_t row,uint8_t colum)
{
    
    //for ROWS
    OLED_send(SSD1306_SET_PAGE_ADDR,1);
    OLED_send(row,1);
    OLED_send(7,1);
    //for colums
    OLED_send(SSD1306_SET_COLUMN_ADDR,1);
    OLED_send(colum,1);
    OLED_send(127,1);
}


 uint16_t  charFontStart;
 uint8_t gylphIndex;

void OLED_Putchar(char c)
{
    //Requiere de imprimir toda una se
        charFontStart = (((uint8_t)c-32)*6)+1;
       gylphIndex = 0;
    for(gylphIndex=0;gylphIndex <6;gylphIndex++)
    {
    OLED_send(DefaultFont[charFontStart+gylphIndex],0);
    }    
}
 uint8_t index;
void OLED_DrawString(const char * string)
{
     index=0;
    while(string[index])
    {
        OLED_Putchar(string[index]);
        index++;
    }   
}


 unsigned int spriteIndex;
void OLED_DrawSprite(uint8_t x,uint8_t y, const uint8_t *sprite,
        unsigned int spriteLenght,
        uint8_t w,uint8_t h,uint8_t Clean) 
{
      //almost same as gotoxy
    //for rows of 8 bits
     OLED_send(SSD1306_SET_PAGE_ADDR,1);
     OLED_send(y,1);
     OLED_send(y+h,1);
    //for colums
     OLED_send(SSD1306_SET_COLUMN_ADDR,1);
     OLED_send(x,1);
     OLED_send(x+w,1);
	 spriteIndex=0;
     //if clean is set , we set to 0 all the sprite zone("cleaning")
     //this is used when we dont have a framebuffer in this case 1024 bytes of ram 
     //8051 external mode could handle this
     while(spriteIndex<spriteLenght){
         OLED_send( Clean?0X00:sprite[spriteIndex],0);
         spriteIndex++;
     }
     OLED_ResetCoords();
}